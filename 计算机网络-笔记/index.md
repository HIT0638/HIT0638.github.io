# 计算机网络 笔记(更新中)

# 前言
这里用来记录我计算机网络学习以及复习过程中的笔记。

# 正题

## ppt知识梳理
### 第二章 
#### HTTP
- 网页包含多个对象，如HTML文件、图片、视频、脚本等。

- 不同主机进程间通信依靠socket，寻址依赖（IP, PORT）
- 对象的寻址依赖于URL，如{www.hit.edu}(host anme){/images/pic.png}(path name)

- 记住，HTTP协议是无状态协议。  
HTTP1.0 非持久连接，一个TCP连接传一个对象；HTTP1.1 持久连接

- 非持久性连接通信的过程。需要注意的点包括建立连接需要一个RTT，html文件请求到接收到消息前几个字节需要一个RTT，一个html文件包含的对象也一样，另外还有文件/对象发送时间。  故total=2*RTT+文件发送时间。

- 非持久性：流水机制，理想情况下，建立连接1RTT，html文件1RTT，收到所有引用对象1RTT，再加上所有文件的发送时间。

#### Cookie
- Cookie建立过程以及原理。  
原理：无cookie的客户端想web服务器发送http请求，服务器为其设置cookie，返回带cookie头部行的http响应信息。  
cookie文件保存在客户端主机，由浏览器管理。  
cookie文件对应的数据也就是用户数据保存在web服务器端数据库。   
当client在次发送包含cookie头部行的请求时，web服务器可以根据cookie来获取对应的用户数据，而产生对该用户的记忆。而无需用户每次请求都需要输入相关信息。

#### Web缓存/代理服务器
- Web缓存/代理服务器  
原理：将请求的Web数据缓存在缓存/代理服务器中。当进行Web访问时，先在缓存/代理服务器中寻找。如果失效或者没有，则正常进行http请求；否则直接转发缓存对象给客户端。  
使用缓存时，用包含if-modified-since来想Web服务器获取缓存状态。如果缓存版本最新，则会接收到`HTTP/1.0 304 Not Modified`，否则不会，说明不是最新。

#### Email
- Email应用  
其构件包括邮件客户端user agent，邮寄服务器email server以及SMTP协议。   
注意的是，邮件的发送和接收是在email server上发生的，user agent仅仅将邮件送到server或者从server拉取邮件。
mail server用邮箱存储接收道德email，同时有一个消息队列存储等待发送的email。

##### SMTP
SMTP需要注意的如下：
+ 是一个‘推’协议，只能将邮件从mail server发送到server，不能被user agent用来从邮箱中‘拉取’邮件。
+ 用TCP，25端口。

- email信息格式：header：to/r/b from/r/n subjetc/r/n body：msg（写着玩的，大概率不考）

- 那如何拉取邮件？有如POP，IMAP或者使用HTTP的163,QQ Mail等。

#### DNS 
关于DNS，需要注意的是：
+ 应用层协议
+ 多层命名，分布式数据库。
+ 功能是将域名解析为IP地址
+ 几层域名的功能：根->顶级->权威（->本地）。
+ 同理，主机不自行完成解析任务，本地域名服务器完成后将结果转发给主机。
+ DNS缓存

DNS协议包括查询query和恢复reply信息，信息格式相同。

#### P2P & 文件分发
- P2P架构
这部分要掌握的就是端系统之间直接通信，没有传统意义上的服务器。  
另外可能出现的计算题是C/S架构和P2P架构的文件分发时间。  
举个栗子，一个服务器向N个节点分发一个文件，文件size为F，服务器上传带宽为$u_s$，节点i上传带宽和下载带宽分别为$u_i$和$d_i$。  
则如果使用C/S架构，那么分发该文件到N节点的时间d_{cs}=max{$\frac{NF}{u_s}$,$\frac{F}{min(d_i)}$}。因为服务器要上传N个文件副本，故有$\frac{NF}{u_s}$，同时，该过程中还有节点的下载时间，如果最慢下载实践比上传N个副本时间都长，那么就有$\frac{F}{min(d_i)}$。  
如果使用P2P架构，那么该过程中涉及的操作及其时间包括‘服务器必须发送一个副本’，客户机i下载时间，总共需要的文件下载时间。故时间$d_{P2P}$=max{$\frac{F}{u_s}$,$\frac{F}{min(d_i)}$,$\frac{NF}{(u_s+\sum{u_i})}$}。  
+ 另外，关于P2P，还有很重要的一点就是其“索引”。  
在P2P中，搜索信息指的是查找网络上的文件或资源。为什么？因为P2P没有中央服务器，因此节点需要通过P2P网络上的其它机制来发现和定位数据。    
##### P2P系统的索引
**P2P系统的索引**，这个‘索引’是名词，它是一个映射表，记录文件/资源和它们所在节点的位置（IP+PORT）之间的关系。这个索引可以是分布式的，分散在网络的多个节点。  
例如，在文件共享系统中，索引会动态跟踪那些节点共享了哪些文件。节点加入网络并想要共享文件时，首先需要告知索引自己的文件列表。当需要找某个文件时，则在索引中搜素具有该文件的节点信息，并从这些节点中下载文件。  
或者在如QQ这样的即时消息系统中，索引的作用是将用户名和账号映射到实际的网络位置。    
具体实现包括：**集中式索引**、**洪泛式查询Query flooding**、层次式覆盖网络。

- 文件分发：BitTorrent，以256KB的chunk对数据进行分发，tit-for-tat.

## 第三章
### 传输层要掌握什么？
+ 理解传输层服务基本理论和基本机制：
  - 复用/分用;
  - 可靠数据传输机制;
  - 流量控制机制；
  - 拥塞控制机制。
+ 掌握Internet的传输层协议：
  - UDP;
  - TCP;
  - TCP拥塞控制。

### 概述
传输层为不同主机的进程提供逻辑上端到端的通信。与网络层比较来说，网络层是提供**主机**之间的逻辑通信机制。而传输层是提供**应用进程**之间的逻辑通信机制。
我们主要掌握两个Internet传输层协议，分别是可靠按序的TCP和Best-effort（尽力而为）的UDP。

### 多路复用和多路分用
我觉得这部分要理解‘**多路**’和‘**复用**’‘**分用**’体现在哪里，需要首先知道没有多路复用或者分用的情况。   
在计算机网络中，对于一个主机来说，物理上可能只有一条网络连接，比如一个网线或者一个无线连接。如果**没有多路复用**，那么你的主机可能就只有一条**单一的通信线路**，即每个应用程序都需要有一个物理的网络连接才能进行通信，这样造成效率低下、成本增加等问题。如果没有多路分用，则各数据到达设备时，没有端口号来识别数据应该传给哪个应用程序。并且造成应用程序冲突。

因此，多路复用就体现在**将单一的网络连接通道被化为逻辑上的多路通道进行复用**，主要完成的工作是每个应用程序数据发送请求被赋予一个**唯一的端口号**，传输层使用端口号来区分不同的应用程序。当数据包被发送到网络时，每个包都会包含这个端口号，以此来标记它属于哪个应用程序。

而多路分用呢则是当各数据包到达设备时，传输层查看每个数据包的‘**目的端口号**’，如何根据端口号将数据发送给绑定该端口的对应应用程序。成功正确的完成数据的接收和转发。

核心知识点就在于**如何标识数据包使得发送方和接收方都能成功分析并完成正确的数据传**输。具体就是‘**端口号**’的设置。
#### UDP & TCP in 多路复用/分用
+ 同时，根据连接存在情况可以分为**无连接的分用UDP**和**有连接的TCP**。  
  - 无连接：UDP发送时被Socket用二元组（目的IP，目的PORT）来进行标识。主机收到UDP后，根据段中的目的PORT来进行向上层的转交。转交的依据仅参考目的PORT，这意味着来自不同源IP和源端口号的IP数据包会被导向同一个Socket。  
  - 有连接：TCP的Socket用四元组（源IP，源PORT，目的IP，目的PORT）来标识。

UDP很简单，因此它带来的优点也是头部开少，又因为没有拥塞控制，故应用可更好的控制发送时间和速率。
对UDP，主要注意以下特点：
+ 基于Internet IP协议，有简单的错误校验（checksum）
+ ‘Best effort’尽力交付服务，UDP段可能丢失或错序到达。
+ 无连接，无需握手。
+ 常用于如流媒体应用一样能够容忍丢失，速率敏感的应用。因为UDP无需握手等繁杂步骤，因此发送速率快于TCP。
+ UDP还用于DNS、SNMP等应用层协议。
+ 通过在应用层加可靠机制和错误恢复机制可以实现UDP的可靠数据传输。
+ UDP校验和（checksum）的计算方法：将段内容视为多个16-bit整数。对所有整数求和后（进位加在后面）按位取反，得到校验和。接收方对接受的段计算校验和后与校验和字段比较，相等则大概率无错；否则错误，丢弃。

### 可靠数据传输
可靠数据传输需要达到的目标是数据传输的不错（检错纠错机制）、不丢（重传机制）、不乱（序号、缓存机制）。
关于rdt1.0到rdt3.0的发展过程不做赘述，具体查看[PDF文档](https://online.fliphtml5.com/ovbgh/xfnp/)
<!-- {{< embed-pdf url="计算机网络-笔记/rdt.pdf" renderPageNum="5">}} -->
<!-- <center><embed src="rdt.pdf"" width="850" height="600"></center> -->

**然后我总结一下**：
- rdt1.0信任底层信道完全可靠，不会发生错误以及丢弃分组；此时发送方和接收方只需要单纯的进行数据的发送和接收即可。  
- rdt2.0中认为信道可能会使比特数据出错，即翻转某些位；故加入了差错检测、接收方反馈控制信息ACK/NAK以及重传策略。  

但rdt2.0中并不能解决ACK/NAK信息出错的情况，同时若ACK/NAK数据出错时简单重传，则会导致**重复分组**的错误情况（因为接收方并不知道发送方是否正确接收ACK/NAK，故在其看来它只要把ACK/NAK发送出去就标志着数据接收成功了）。  

- 故在rdt2.1中，加入了ACK/NAK错误重传机制，并且为了解决重复分组问题，引进了**序列号**方法，即发送方为每个分组增加序列号，接收方会丢弃重复到达的分组。  

- rdt2.2中，NAK信息被认为是多余的，故删去了NAK消息，通过在ACK中加入被确认分组的序号策略来完成其工作；逻辑为发送方收到重复ACK以后，重传该ACK确认分组序号+1的分组。  

在此之前的所有rdt版本中，都默认了信道不会发生分组丢失的情况，那如果会呢？这时候‘校验和+序列号+ACK+重传’机制能解决问题吗？    
显然是不能的，很简单，如果ACK在过程中丢失，那么两方则再也不知道该怎么做了。    

- 因此，在rdt3.0中，为了解决这个问题，引入了“定时器”策略；即为发送方设置一个计时器，如果在规定的合理时间内没有收到期望的ACK，则认为数据包/ACK丢失，重传丢失数据包；同时，如果分组/ACK只是延迟而未丢失，则出现了重复分组情况，但我们已经有序列号机制来解决这个问题了。  

#### rdt3.0
虽然rdt3.0确实能可靠的进行工作，但有一个问题，就是性能很差。  
在这里有一个公式需要注意，即：
$$发送方利用率U_{sender}=\frac{\frac{L}{R}}{RTT + \frac{L}{R}}$$  

发送方的利用率就是一个数据包成功传输所需要的时间里，实际上正在发送数据的时间占比。除去实际发送数据的时间，剩下的时间都是在传输过程中浪费或者消耗的。通过计算这个发送方利用率，可以评判数据发送的效率，即发现是不是大多数时候在做无用功。

同时，我们下面介绍三个实现可靠数据传输的方式，停等协议、流水线机制、滑动窗口协议，并分析它们的性能。

### 停等协议
主要理解每次只能发一个分组，并且sender接收到该分组的ACK后才能发送下一个分组。  
示例：1Gbps链路，15ms端到端传播延迟，1KB分组：
{{< image src="images/计算机网络-笔记/waitstop.png" height=200 >}}

如图所示，大小为L的文件传输，发送时耗$\frac{L}{R}$，传播时延1个RTT。因此计算的到发送方利用率只有0.00027。约等于30毫秒才发送一个分组，很慢。

### 流水线机制
使用流水线机制的情况如图：
flow

如图所示采用如图流水线机制改进数据传输后（一次可以发3个并且接收到正确ACK后就发一下个），经过计算发送方利用率可以发现利用率提高了将近3倍。当然这是没有差错或丢失的情况。

流水线协议允许发送方在收到ACK之前连续发送多个分组。这表示其有着更大的序列号范围以及可能需要缓存分组。
### 滑动窗口协议
关于滑动窗口协议，主要掌握的就是其思想以及各种应对状态的措施。  
窗口代表着当前可以发送的分组组合，并且以窗口为单位对分组进行划分和管理。  

**需要注意的出题点如下**：
- 序列号问题，n位序列字段可以分配0~$2^{n-1}$的序列号。  
- 序列号按模n编号。
- 接受数据**序号重叠**问题，这要求窗口的长度必须小于等于总区间（序号）长度的一半。
...

另外，滑动窗口协议的具体实现方式包括GBN(Give-Back-N)和SR(Select Repeat)。

#### GBN协议

