# 计算机网络 笔记(更新中)

# 前言
这里用来记录我计算机网络学习以及复习过程中的笔记。

# 正题

## ppt知识梳理
### 应用层 
#### HTTP
- 不同主机进程间**通信依靠socket**，**寻址依赖（IP, PORT）**。
- 对象的寻址依赖于URL，如{www.hit.edu}(host anme){/images/pic.png}(path name)。
- 记住，HTTP协议是**无状态协议**。  
HTTP1.0 非持久连接，一个TCP连接传一个对象；HTTP1.1 持久连接。

- **非持久性连接**通信的过程。需要注意的点包括建立连接需要一个RTT，html文件请求到接收到消息前几个字节需要一个RTT，一个html文件包含的对象也一样，另外还有文件/对象发送时间。  故total=2*RTT+文件发送时间。
{{< image src="images/计算机网络-笔记/httpnon.png" height=300 >}}

- 持久性：流水线机制，理想情况下，建立连接1RTT，html文件1RTT，收到所有引用对象1RTT，再加上所有文件的发送时间。
{{< image src="images/计算机网络-笔记/httppipe.png" height=300 >}}

#### Cookie
- Cookie建立过程以及原理。  
  **原理**：
  - 无cookie的客户端向web服务器发送http请求->服务器为其设置cookie->返回带cookie头部行的http响应信息。  
  - cookie文件**保存在客户端主机，由浏览器管理**。  
  - cookie文件对应的数据也就是**用户数据保存在web服务器端数据库**。   
  - 当client在次发送包含cookie头部行的请求时，web服务器可以根据cookie来获取对应的用户数据，而产生对该用户的记忆。而无需用户每次请求都需要输入相关信息。

#### Web缓存/代理服务器
- Web缓存/代理服务器  
**原理**：  
将请求的Web数据缓存在缓存/代理服务器中。当进行Web访问时，先在缓存/代理服务器中寻找。如果失效或者没有，则正常进行http请求；否则直接转发缓存对象给客户端。  
使用缓存时，用包含if-modified-since来想Web服务器获取缓存状态。如果缓存版本最新，则会接收到`HTTP/1.0 304 Not Modified`，否则不会，说明不是最新。

#### Email
- Email应用  
其构件包括**邮件客户端user agent**，**邮寄服务器email server**以及**SMTP协议**。   
注意的是，邮件的发送和接收是在email server上发生的，user agent仅仅将邮件送到server或者从server拉取邮件。
mail server用邮箱存储接收道德email，同时有一个消息队列存储等待发送的email。

##### SMTP
SMTP需要注意的如下：
+ 是一个‘**推**’协议，只能将邮件从mail server发送到server，不能被user agent用来从邮箱中‘拉取’邮件。
+ 用TCP，25端口。

- email信息格式：  
```
header：
to: 
from: 
subjetc: 

body：msg
（写着玩的，大概率不考）
```

- 那如何拉取邮件？有如POP，IMAP或者使用HTTP的163,QQ Mail等。

#### DNS 
关于DNS，需要注意的是：
+ 应用层协议
+ 多层命名，分布式数据库。
+ 功能是将域名解析为IP地址
+ 几层域名的功能：根->顶级->权威（->本地）。
+ 同理，主机不自行完成解析任务，本地域名服务器完成后将结果转发给主机。
+ DNS缓存

DNS协议包括查询query和恢复reply信息，信息格式相同。

#### P2P & 文件分发
- P2P架构
这部分要掌握的就是端系统之间直接通信，没有传统意义上的服务器。另外可能出现的计算题是**C/S架构和P2P架构的文件分发时间**。  
举个栗子，一个服务器向N个节点分发一个文件，文件size为F，服务器上传带宽为$u_s$，节点i上传带宽和下载带宽分别为$u_i$和$d_i$。  
则如果使用C/S架构，那么分发该文件到N节点的时间$$d_{cs}=max{\frac{NF}{u_s},\frac{F}{min(d_i)}}$$  
因为服务器要上传N个文件副本，故有$\frac{NF}{u_s}$的耗时；同时，该过程中还有节点的下载时间，如果最慢下载时间比上传N个副本时间都长，那么就有$\frac{F}{min(d_i)}$。  
如果使用P2P架构，那么该过程中涉及的操作及其时间包括‘服务器必须发送一个副本’，客户机i下载时间，总共需要的文件下载时间。故时间$$d_{P2P}=max{\frac{F}{u_s},\frac{F}{min(d_i)},\frac{NF}{(u_s+\sum{u_i})}}$$  

+ 另外，关于P2P，还有很重要的一点就是其“**索引**”。  
在P2P中，搜索信息指的是查找网络上的文件或资源。为什么？因为P2P没有中央服务器，因此节点需要通过P2P网络上的其它机制来发现和定位数据。    
##### P2P系统的索引
- **P2P系统的索引**：  
这个‘**索引**’是名词，它是一个映射表，记录文件/资源和它们所在节点的位置（IP+PORT）之间的关系。这个索引可以是分布式的，分散在网络的多个节点。  
例如，在文件共享系统中，索引会动态跟踪那些节点共享了哪些文件。节点加入网络并想要共享文件时，首先需要告知索引自己的文件列表。当需要找某个文件时，则在索引中搜素具有该文件的节点信息，并从这些节点中下载文件。  
或者在如QQ这样的即时消息系统中，索引的作用是将用户名和账号映射到实际的网络位置。    
具体实现包括：**集中式索引**、**洪泛式查询Query flooding**、层次式覆盖网络。

- 文件分发：BitTorrent，以256KB的chunk对数据进行分发，tit-for-tat.

### 传输层
#### 传输层要掌握什么？
+ 理解传输层服务基本理论和基本机制：
  - 复用/分用;
  - 可靠数据传输机制;
  - 流量控制机制；
  - 拥塞控制机制。
+ 掌握Internet的传输层协议：
  - UDP;
  - TCP;
  - TCP拥塞控制。

#### 概述
传输层为不同主机的进程提供逻辑上端到端的通信。与网络层比较来说，网络层是提供**主机**之间的逻辑通信机制。而传输层是提供**应用进程**之间的逻辑通信机制。
我们主要掌握两个Internet传输层协议，分别是可靠按序的TCP和Best-effort（尽力而为）的UDP。

#### 多路复用和多路分用
我觉得这部分要理解‘**多路**’和‘**复用**’‘**分用**’体现在哪里，需要首先知道没有多路复用或者分用的情况。   
在计算机网络中，对于一个主机来说，物理上可能只有一条网络连接，比如一个网线或者一个无线连接。如果**没有多路复用**，那么你的主机可能就只有一条**单一的通信线路**，即每个应用程序都需要有一个物理的网络连接才能进行通信，这样造成效率低下、成本增加等问题。如果没有多路分用，则各数据到达设备时，没有端口号来识别数据应该传给哪个应用程序。并且造成应用程序冲突。

因此，多路复用就体现在**将单一的网络连接通道被化为逻辑上的多路通道进行复用**，主要完成的工作是每个应用程序数据发送请求被赋予一个**唯一的端口号**，传输层使用端口号来区分不同的应用程序。当数据包被发送到网络时，每个包都会包含这个端口号，以此来标记它属于哪个应用程序。

而多路分用呢则是当各数据包到达设备时，传输层查看每个数据包的‘**目的端口号**’，如何根据端口号将数据发送给绑定该端口的对应应用程序。成功正确的完成数据的接收和转发。

核心知识点就在于**如何标识数据包使得发送方和接收方都能成功分析并完成正确的数据传**输。具体就是‘**端口号**’的设置。
##### UDP & TCP in 多路复用/分用
+ 同时，根据连接存在情况可以分为**无连接的分用UDP**和**有连接的TCP**。  
  - 无连接：UDP发送时被Socket用二元组（目的IP，目的PORT）来进行标识。主机收到UDP后，根据段中的目的PORT来进行向上层的转交。转交的依据仅参考目的PORT，这意味着来自不同源IP和源端口号的IP数据包会被导向同一个Socket。  
  - 有连接：TCP的Socket用四元组（源IP，源PORT，目的IP，目的PORT）来标识。

UDP很简单，因此它带来的优点也是头部开少，又因为没有拥塞控制，故应用可更好的控制发送时间和速率。
对UDP，主要注意以下特点：
+ 基于Internet IP协议，有简单的错误校验（checksum）
+ ‘Best effort’尽力交付服务，UDP段可能丢失或错序到达。
+ 无连接，无需握手。
+ 常用于如流媒体应用一样能够容忍丢失，速率敏感的应用。因为UDP无需握手等繁杂步骤，因此发送速率快于TCP。
+ UDP还用于DNS、SNMP等应用层协议。
+ 通过在应用层加可靠机制和错误恢复机制可以实现UDP的可靠数据传输。
+ UDP校验和（checksum）的计算方法：将段内容视为多个16-bit整数。对所有整数求和后（进位加在后面）按位取反，得到校验和。接收方对接受的段计算校验和后与校验和字段比较，相等则大概率无错；否则错误，丢弃。

#### 可靠数据传输
可靠数据传输需要达到的目标是数据传输的不错（检错纠错机制）、不丢（重传机制）、不乱（序号、缓存机制）。
关于rdt1.0到rdt3.0的发展过程不做赘述，具体查看[PDF文档](https://online.fliphtml5.com/ovbgh/xfnp/)
<!-- {{< embed-pdf url="计算机网络-笔记/rdt.pdf" renderPageNum="5">}} -->
<!-- <center><embed src="rdt.pdf"" width="850" height="600"></center> -->

**然后我总结一下**：
- rdt1.0信任底层信道完全可靠，不会发生错误以及丢弃分组；此时发送方和接收方只需要单纯的进行数据的发送和接收即可。  
- rdt2.0中认为信道可能会使比特数据出错，即翻转某些位；故加入了差错检测、接收方反馈控制信息ACK/NAK以及重传策略。  

但rdt2.0中并不能解决ACK/NAK信息出错的情况，同时若ACK/NAK数据出错时简单重传，则会导致**重复分组**的错误情况（因为接收方并不知道发送方是否正确接收ACK/NAK，故在其看来它只要把ACK/NAK发送出去就标志着数据接收成功了）。  

- 故在rdt2.1中，加入了ACK/NAK错误重传机制，并且为了解决重复分组问题，引进了**序列号**方法，即发送方为每个分组增加序列号，接收方会丢弃重复到达的分组。  

- rdt2.2中，NAK信息被认为是多余的，故删去了NAK消息，通过在ACK中加入被确认分组的序号策略来完成其工作；逻辑为发送方收到重复ACK以后，重传该ACK确认分组序号+1的分组。  

在此之前的所有rdt版本中，都默认了信道不会发生分组丢失的情况，那如果会呢？这时候‘校验和+序列号+ACK+重传’机制能解决问题吗？    
显然是不能的，很简单，如果ACK在过程中丢失，那么两方则再也不知道该怎么做了。    

- 因此，在rdt3.0中，为了解决这个问题，引入了“定时器”策略；即为发送方设置一个计时器，如果在规定的合理时间内没有收到期望的ACK，则认为数据包/ACK丢失，重传丢失数据包；同时，如果分组/ACK只是延迟而未丢失，则出现了重复分组情况，但我们已经有序列号机制来解决这个问题了。  

##### rdt3.0
虽然rdt3.0确实能可靠的进行工作，但有一个问题，就是性能很差。  
在这里有一个公式需要注意，即：
$$发送方利用率U_{sender}=\frac{\frac{L}{R}}{RTT + \frac{L}{R}}$$  

发送方的利用率就是一个数据包成功传输所需要的时间里，实际上正在发送数据的时间占比。除去实际发送数据的时间，剩下的时间都是在传输过程中浪费或者消耗的。通过计算这个发送方利用率，可以评判数据发送的效率，即发现是不是大多数时候在做无用功。

同时，我们下面介绍三个实现可靠数据传输的方式，停等协议、流水线机制、滑动窗口协议，并分析它们的性能。

##### 停等协议
主要理解每次只能发一个分组，并且sender接收到该分组的ACK后才能发送下一个分组。  
示例：1Gbps链路，15ms端到端传播延迟，1KB分组：
{{< image src="images/计算机网络-笔记/waitstop.png" height=200 >}}

如图所示，大小为L的文件传输，发送时耗$\frac{L}{R}$，传播时延1个RTT。因此计算的到发送方利用率只有0.00027。约等于30毫秒才发送一个分组，很慢。

##### 流水线机制
使用流水线机制的情况如图：
{{< image src="images/计算机网络-笔记/pipeline.png" height=300 >}}

如图所示采用流水线机制改进数据传输后（一次可以发3个并且接收到正确ACK后就发一下个），经过计算发送方利用率可以发现利用率提高了将近3倍。当然这是没有差错或丢失的情况。

流水线协议允许发送方在收到ACK之前连续发送多个分组。这表示其有着更大的序列号范围以及可能需要缓存分组。
##### 滑动窗口协议
关于滑动窗口协议，主要掌握的就是其思想以及各种应对状态的措施。  
窗口代表着当前可以发送的分组组合，并且以窗口为单位对分组进行划分和管理。  

**需要注意的出题点如下**：
- 序列号问题，n位序列字段可以分配0~$2^{n-1}$的序列号。  
- 序列号按模n编号。
- 接受数据**序号重叠**问题，这要求窗口的长度必须小于等于总区间（序号）长度的一半。
...

另外，滑动窗口协议的具体实现方式包括GBN(Go-Back-N)和SR(Select Repeat)。

##### GBN协议
GBN协议主要需要注意的是其**应答特征以及策略**。  
如图：
{{< image src="images/计算机网络-笔记/gbn.png" height=200 >}}

我认为GBN主要需要注意的特征是：
- GBN的发送窗口大小m大于等于1，接收窗口大小只能为1。
- sender为整个窗口设置一个定时器，当窗口做左侧即第一个分组send_base的ACK到达时，窗口定时器重置，同时窗口向右滑动。
- 当sender未能成功接收send_base分组的ACK导致超时时，重传当前窗口内**已发送**但还未收到ACK的所有分组；也就是如图[send_base,nextseqnum)的所有分组。
- 由于接受窗口的大小为1，如果接收到的是该窗口分组，则发送对应ACK并挪动窗口；故乱序到达的分组，都会被丢弃，并且重传最近确认分组序号的ACK。
- 特殊情况：当sender接收到了大于send_base序号的分组（假如是n）时，由于接收方窗口为1的缘故，故可以得出n及n以前的分组都已经被正确接收了，故可以直接挪动窗口send_base到n+1。

下面是GBN的有限状态机图，可供捋过程的时候参考使用：
- 发送方：
{{< image src="images/计算机网络-笔记/gbnfsms.png" height=300 >}}
- 接收方：
{{< image src="images/计算机网络-笔记/gbnfsmr.png" height=300 >}}

课上习题：
{{< image src="images/计算机网络-笔记/gbnpra.png" height=300 >}}

##### SR协议
SR协议，即选择重传协议。和GBN的区别在于对接收到的窗口内分组的ACK进行缓存，并且为每个发送出去的分组设置一个定时器，当i分组的定时器超时时，只会重传i分组；而不像GBN一样重传所有的已发送但未收到ACK的分组。  
也因为如此，SR协议的接收方窗口不再限制为1，而可以是任意非零正数。

SR协议的发送方、接收方状态转移情况以及应答措施：  
- 发送方&接收方：
{{< image src="images/计算机网络-笔记/srfsm.png" height=300 >}}

### TCP
#### 概述
TCP是实现可靠数据传输的服务，基于IP层提供的不可靠服务。

我觉得需要注意的点有：
- 全双工，同一连接中能传输双向数据流
- 拥塞控制以及流量控制
- TCP段结构中，需要注意的是序列号seq和确认号ack。因为进行的是全双工通信，所以双方需要用seq和ack来互相同步数据的双向传输。  
seq的作用是表明‘**我**’本次发送的数据的第一个字节的编号（不一定从0开始，建立TCP连接时，双方随机选择序列号）。ack的作用是表示'**我**'下一个希望接收（你的）到的下一个字节的序号，其实就是我希望你发送的数据的起始字节是哪个。同时，由于TCP使用**累计确认**的方式，该ack序列号之前的所有字节均已正确接受。

#### TCP可靠数据传输
主要包括这些点：
- 流水线机制。
- 累计确认。
- TCP使用单一重传定时器。
- 触发重传的事件包括超时和收到重复ACK。

注意几点，1是超时时间（RTO）的计算，2是累计确认方式，3是TCP的重传机制。  

##### RTO的计算
TCP会计算每次数据传输的RTT，并且利用该RTT来更新超时时间，我们假设每次测量到的RTT为$SampleRTT$，则RTO计算公式如下：
$$RTO = EstimatedRTT + 4 \times DevRTT$$
$$EstimatedRTT = (1-\alpha)\times EstimatedRTT + \alpha \times SampleRTT, \alpha 典型值为0.125$$
$$DevRTT = (1-\beta) \times DevRTT + \beta \times |SampleRTT - EstimatedRTT|$$

EstimatedRTT是平滑RTT，为了避免临时网络波动的影响，故采用加权移动平均（EWMA）算法来计算更平滑的RTT。  
DevRTT衡量了RTT的波动程度，反映网络中的不稳定性。

##### 累计确认
累计确认的工作原理是：  
接收方不必对每个单独的数据包发送确认，而是可以在收到多个数据包后，发送一个确认信息，表明它已经接收到所有序号小于或等于某个特定值的数据包。这意味着累计确认是对所有前面连续的数据包的确认。

##### TCP重传
TCP只设置1个定时器，并且超时后只会重传1个分组，这个分组是还没有被确认的**最早的一个分组**。  
当这个分组被成功接收，并且接收方返回了一个累积确认后，发送方才会知道之后的分组是否也在传输过程中丢失。如果累积确认的序号增加了，那么发送方会推断出之后的分组也被成功接收了。如果没有，那么发送方可能需要继续重传后续的分组，但这通常会发生在随后的超时事件之后。

#### 流量控制
流量控制部分很简单，就是一个**速度匹配机制**。通过限制sender窗口大小来控制流量。  
Receiver通过在Segment的头部字段将**RcvWindow**告诉Sender->Sender根据RcvWindow来限制自己的能够发送的数据数量，即已经发送但还未收到ACK的数据多少。

#### TCP的连接管理
TCP的连接管理包括TCP连接的建立和关闭，即三次握手和四次挥手。  

- 三次握手（TCP连接建立）：
	- 第一次握手：客户端发送一个带有SYN（同步序列编号）标志的TCP段到服务器以开始一个新的连接。
	- 第二次握手：服务器接收到SYN后，回送一个带有SYN/ACK标志的TCP段作为应答。
	- 第三次握手：最后，客户端发送一个带有ACK标志的TCP段来确认这个响应   

这个过程，双方在建立连接的过程中同步了seq和ack序列号。  
如图：
{{< image src="images/计算机网络-笔记/handshake.png" height=300 >}}

- 四次挥手（TCP连接关闭）：
	- 第一次挥手：当通信的一方完成其数据发送任务后，它会发送一个带有FIN标志的TCP段来关闭连接。
	- 第二次挥手：另一方接收到这个FIN后，会发送ACK来确认收到了连接释放请求。
	- 第三次挥手：接收FIN的一方等到其所有待发送的数据都发送完毕后，也会发送一个FIN来指示它也准备关闭连接了。
	- 第四次挥手：最初发送FIN的一方在收到这个FIN后，发送一个ACK来确认，然后等待足够长的时间确保另一方收到了这个ACK，最后关闭连接。

如图：
{{< image src="images/计算机网络-笔记/handwave.png" height=300 >}}

#### 拥塞控制
TCP采用端系统的拥塞控制，主要概念包括：
- 慢启动
- 拥塞避免
- 快重传
- 快恢复

过程总结如下：
- 当拥塞窗口（CongWin）小于阈值时，发送方处于慢启动阶段，窗口呈指数增长。
- 当拥塞窗口大于阈值时，发送方进入拥塞避免阶段，窗口呈线性增长。
- 当发生三个重复的ACK时，阈值设置为拥塞窗口的一半，拥塞窗口设置为阈值，进入状态’拥塞避免‘。
- 当发生超时时，阈值设置为拥塞窗口的一半，拥塞窗口设置为1个最大段大小（MSS）。

各含义解释如下：
| 状态       | 事件                           | TCP发送方动作                                   | 注释                             |
|------------|--------------------------------|------------------------------------------------|----------------------------------|
| 慢启动 (SS) | 收到对之前未确认数据的确认(ACK) | CongWin = CongWin + MSS, 如果 (CongWin > 阈值) 则状态设置为 “拥塞避免” | 导致每个RTT拥塞窗口翻倍         |
| 拥塞避免 (CA) | 收到对之前未确认数据的确认(ACK) | CongWin = CongWin + MSS * (MSS/CongWin)        | 加性增加，导致每个RTT拥塞窗口增加1个MSS |
| SS 或 CA   | 通过三个重复的ACK检测到丢失事件   | 阈值 = CongWin/2, CongWin = 阈值, 状态设置为 “拥塞避免” | 快速恢复，实现乘法减小。拥塞窗口不会下降至低于1个MSS |
| SS 或 CA   | 超时                           | 阈值 = CongWin/2, CongWin = 1 MSS, 状态设置为 “慢启动” | 进入慢启动                     |

### 网络层 & 数据链路层
网络层和数据链路层的数据我是手写的，有时间了再慢慢码字上传。

### 数据链路层
链路层协议如何实现？链路层协议的实现依赖于“适配器”，即网络接口卡-NIC及其驱动。另外，物理层协议也是由网卡实现的。  
在物理层面上依赖于网卡以及各种软硬件。  
- 以太网网卡：802.11网卡；以太网芯片组

如图是网卡间的通信：
{{< image src="images/计算机网络-笔记/NIC.png" height=300 >}}

#### MAC协议
MAC（multiple access control）协议，即多路访问控制协议，是用来确保多结点能正确在共享广播信道上传输数据的协议。  

首先要知道有两类链路：
- 点对点链路
	- 拨号接入的PPP
	- 以太网交换机和主机之间的点对点链路
- **广播链路（共享介质）**
	- 早期总线以太网	
	- 802.11无线局域网

在单一共享广播信道上传输时，若出现两个或两个以上结点同时传输的情况，则会出现数据传输的**干扰**；另外，若结点同时接收到两个或者多个信号，则会产生**冲突**，导致接受失败。

##### MAC协议的分类
- 信道划分MAC协议
	- 多路复用技术
	- TDMA（时分）、FDMA（频分）、CDMA（码分）、WDMA...
- 随机访问MAC协议
	- 信道不划分，允许冲突；并采用冲突**恢复**机制来控制结点的访问。
	- ALOHA，时隙ALOHA、、CSMA、CSMA/CD、CSMA\CA
- 轮转MAC协议
	- 结点轮流使用信道
	- 主结点轮询；令牌传递

#### MAC地址
互联网中的每一个网卡都有一个唯一的MAC地址。

#### 以太网
以太网是一种局域网技术。
{{< admonition type=info title="局域网技术" open=true >}}
局域网技术一般专注于OSI模型的底层，也就是数据链路层和物理层。  
局域网技术通常不涉及网络层及以上层次的事务，如路由选择、数据分段、会话管理等，这些是由更高层的网络协议（如IP协议）来处理的。局域网的设计通常假设网络中的所有设备都在同一个广播域中，这意味着它们可以直接通过数据链路层通信，而无需进行复杂的路由决策。
{{< /admonition >}}

以下是需要注意的点：
- 以太网提供无连接、不可靠的服务，如没有握手过程，差错帧直接丢弃等。  
- 以太网的MAC协议使用**二进制指数退避算法的CSMA/CD**。

##### 以太网帧结构
以太网的帧结构如图：
{{< image src="images/计算机网络-笔记/framestructure.png" >}}
包括前导码、源/目的MAC地址、上层协议类型、数据以及CRC循环冗余校验码。

#### 交换机
以太网交换机包含以下四个特点：
- 属于链路层设备：进行存储转发以太帧；利用CSMA/CD访问链路。
- 透明：主机感知不到交换机的存在。
- 即插即用。
- **自学习**。

##### 交换表 & 自学习
每个交换机都有一个交换表，表项格式如：  
`(主机MAC地址，到达主机的接口，时间戳)`
如图：

同时，交换机采用自学习来获知转发信息的策略：
- 当收到帧时，交换机通过帧的源MAC地址，学习到**该主机位于接收到该帧接口的LAN网段。**然后将发送主机MAC地址/接口记录到交换表中。

若交换机接收到的帧所标识的目的MAC地址不在表项中，则使用**泛洪法**（向除接收到该帧的接口之外的所有接口转发）来进行学习。

总而言之，交换机自学习和转发的过程可以被概括为：**泛洪**与**选择性转发**。




